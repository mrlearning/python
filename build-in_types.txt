Встроенные типы данных:
1) Логические значения: True/False. По умолчанию, каждый объект - True, если в нём не определён метод __bool__(), возвращающий False или метод __len__(), возвращающий 0.

2) Числовые типы - int, float, complex.

3) Последовательности - list, tuple, range
	list - динамический массив ссылок на объекты
	tuple - неизменяемый список. Кортежи используются: при работе с аргументами и параметрами; когда функция возвращает несколько элементов; при итерации по словарю; при форматировании строк; и т.д.
	range - неизменяемая последовательность чисел, заданная начальным значением, максимальным значением и шагом. Аргументами конструктора могут служить целые числа или объекты, реализующие метод __index__()

4) Последовательности символов unicode - строки.

5) Бинарные последовательности - bytes, bytearray, memoryview¶
	bytes - неизменяемая последовательность байт
	bytearray - изменяемая последовательность байт

6) Наборы - set, frozenset
	set - неупорядоченная коллекция хешируемых объектов без дубликатов. В основе лежит хеш-таблица с фиктивными значениями и оптимизацией.

7) Отображения - dict
	Словарь реализован как хеш-таблица. Колизии решаются методом открытой адресации, т.е. таблица представляет собой массив пар ключ-значение и, если ячейка занята, то элемент заносится в следующую свободную ячейку.

8) Итераторы
	Представляет собой объект, позволяющий получить последовательный доступ к элементам коллекции (массива или контейнера), не раскрывая её внутреннего представления. В терминах СУБД итераторы называют курсорами. В простейшем случае итератором в низкоуровневых языках является указатель. В Python итератор - это объект, класс которого реализует методы __iter__() и __next__(). Итерируемый объект обязан иметь только метод __iter__(), возвращающий итератор. В цикл for можно передавать как итерируемый объект, так и сам итератор, т.к. сначала автоматически вызывается __iter__().

-------Пример-------
class Iterator:
    def __init__(self, start_val, max_val):
        self.val = start_val
        self.max = max_val

    def __iter__(self):
        return self

    def __next__(self):
        if self.val <= self.max:
            x, self.val = self.val, self.val+1
            return x
        else:
            raise StopIteration
        

class IterableObject:
    def __init__(self, start, end):
        self.start = start
        self.end = end
        
    def __iter__(self):
        return Iterator(self.start, self.end)
--------------------


9) Генераторы
	Генератор - функция, позволяющая поочерёдно получать элементы последовательности, не создавая сразу всего набора элементов. Следующий элемент вычисляется при каждом новом вызове функции. Для создания генераторов используют функции, содержащие в своем теле ключевое слово «yield» — такие функции возвращают объект-генератор. 
В Python генераторы - это инструмент для создания итераторов. Представляют собой функцию, содержащую в своем теле ключевое слово «yield» в том месте, где необходимо вернуть данные. Генератор хранит значения переменных и выхажение, на котором остановился, и при вызове метода __next__() возобновляет работу с места остановки. Отличие генератора от итератора:
a) генератор реализован в виде функции
b) генератор автоматически реализует методы __iter__() и __next__()
c) генератор автоматически сохраняет между вызовами значения локальных переменных и состояние выполнения
d) генератор автоматически вызывает StopIteration при завершении
-------Пример-------
def my_gen(n):
    i = 0
    while i < n:
        yield a
	i += 1

for el in my_gen(10):
    print(el)
--------------------

10) Контекст менеджер
	Менеджеры контекста служат для автоматизации освобождения ресурсов. В python менеджер контекста реализан как объект с методами __enter__() и __exit___(). __enter__() вызывается при входе в блок with и возвращает ссылку на объект, которая присваивается переменной после ключевого слова as. __exit___() выполняется при выходе из контекста.

-------Пример-------
class File:
    def __init__(self, file_path, method):
        self.path = file_path
        self.method = method

    def __enter__(self):
        self.file = open(self.path, self.method)
        return self.file

    def __exit__(self):
        self.file.close()

my_file = File("hello.txt", "w")
with my_file as f:
    f.write("hello") 
--------------------
