Встроенные типы данных:
1) Логические значения: True/False. По умолчанию, каждый объект - True, если в нём не определён метод __bool__(), возвращающий False или метод __len__(), возвращающий 0.

2) Числовые типы - int, float, complex.

3) Последовательности - list, tuple, range
	list - динамический массив ссылок на объекты
	tuple - неизменяемый список. Кортежи используются: при работе с аргументами и параметрами; когда функция возвращает несколько элементов; при итерации по словарю; при форматировании строк; и т.д.
	range - неизменяемая последовательность чисел, заданная начальным значением, максимальным значением и шагом. Аргументами конструктора могут служить целые числа или объекты, реализующие метод __index__()

4) Последовательности символов unicode - строки.

5) Бинарные последовательности - bytes, bytearray, memoryview¶
	bytes - неизменяемая последовательность байт
	bytearray - изменяемая последовательность байт

6) Наборы - set, frozenset
	set - неупорядоченная коллекция хешируемых объектов без дубликатов. В основе лежит хеш-таблица с фиктивными значениями и оптимизацией.

7) Отображения - dict
	Словарь реализован как хеш-таблица. Колизии решаются методом открытой адресации, т.е. таблица представляет собой массив элементов (ключ-значение) и, если ячейка занята, то элемент заносится в следующую ячейку.

8) Итераторы
	Представляет собой объект, позволяющий получить последовательный доступ к элементам коллекции (массива или контейнера), не раскрывая её внутреннего представления. В терминах СУБД итераторы называют курсорами. В простейшем случае итератором в низкоуровневых языках является указатель. В Python итератор - это объект, класс которого реализует методы __iter__() и __next__(). Итерируемый объект обязан иметь только метод __iter__(), возвращающий итератор. В цикл for можно передавать как итерируемый объект, так и сам итератор, т.к. сначала автоматически вызывается __iter__().
-------Пример-------
class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):
        if self.a <= 20:
            x = self.a
            self.a += 1
            return x
        else:
            raise StopIteration

for el in MyNumbers():
    print(el)
--------------------


9) Генераторы
	Генератор - функция, позволяющая поочерёдно получать элементы последовательности, не создавая сразу всего набора элементов. Следующий элемент вычисляется при каждом новом вызове функции. Для создания генераторов используют функции, содержащие в своем теле ключевое слово «yield» — такие функции возвращают объект-генератор. 
В Python генераторы - это инструмент для создания итераторов. Представляют собой функцию, содержащую в своем теле ключевое слово «yield» в том месте, где необходимо вернуть данные. Генератор хранит значения переменных и выхажение, на котором остановился, и при вызове метода __next__() возобновляет работу с места остановки. Отличие генератора от итератора:
a) генератор реализован в виде функции
b) генератор автоматически реализует методы __iter__() и __next__()
c) генератор автоматически сохраняет между вызовами значения локальных переменных и состояние выполнения
d) генератор автоматически вызывает StopIteration при завершении
-------Пример-------
def my_gen(n):
    i = 0
    while i < n:
        yield a
	i += 1

for el in my_gen(10):
    print(el)
--------------------

10) Контекст менеджер
	Менеджеры контекста позволяют автоматизировать освобождение ресурсов. В python менеджер контекста реализан как объект с методами __enter__() и __exit___(). __enter__() выполняется при входе в блок with и возвращает ссылку на объект, которая присваивается переменной после ключевого слова as. __exit___() выполняется при выходе из контекста.
