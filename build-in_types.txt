Встроенные типы данных:
1) Тип None. Синглтон, т.е. у типа None только один объект - None.
2) Логические значения: True/False. По умолчанию, каждый объект - True, если в нём не определён метод __bool__(), возвращающий False или метод __len__(), возвращающий 0.

3) Числовые типы - int, float, complex.

4) Последовательности - list, tuple, range
	list - динамический массив ссылок на объекты
	tuple - неизменяемый список. Кортежи используются: при работе с аргументами и параметрами; когда функция возвращает несколько элементов; при итерации по словарю; при форматировании строк; и т.д.
	range - неизменяемая последовательность чисел, заданная начальным значением, максимальным значением и шагом. Аргументами конструктора могут служить целые числа или объекты, реализующие метод __index__()

5) Последовательности символов unicode - строки.

6) Бинарные последовательности - bytes, bytearray, memoryview¶
	bytes - неизменяемая последовательность байт
	bytearray - изменяемая последовательность байт

7) Наборы - set, frozenset
	set - неупорядоченная коллекция хешируемых объектов без дубликатов. В основе лежит хеш-таблица с фиктивными значениями и оптимизацией.

8) Отображения - dict
	Словарь реализован как хеш-таблица. Колизии решаются методом открытой адресации, т.е. таблица представляет собой массив пар ключ-значение и, если ячейка занята, то элемент заносится в следующую свободную ячейку.

9) Итераторы
	Представляет собой объект, позволяющий получить последовательный доступ к элементам коллекции (массива или контейнера), не раскрывая её внутреннего представления. В терминах СУБД итераторы называют курсорами. В простейшем случае итератором в низкоуровневых языках является указатель. В Python итератор - это объект, класс которого реализует методы __iter__() и __next__(). Итерируемый объект обязан иметь только метод __iter__(), возвращающий итератор. В цикл for можно передавать как итерируемый объект, так и сам итератор, т.к. сначала автоматически вызывается __iter__().

-------Пример-------
class Iterator:
    def __init__(self, start_val, max_val):
        self.val = start_val
        self.max = max_val

    def __iter__(self):
        return self

    def __next__(self):
        if self.val <= self.max:
            x, self.val = self.val, self.val+1
            return x
        else:
            raise StopIteration
        

class IterableObject:
    def __init__(self, start, end):
        self.start = start
        self.end = end
        
    def __iter__(self):
        return Iterator(self.start, self.end)
--------------------


10) Генераторы
	Генератор - функция, позволяющая поочерёдно получать элементы последовательности, не создавая сразу всего набора элементов. Следующий элемент вычисляется при каждом новом вызове функции. Для создания генераторов используют функции, содержащие в своем теле ключевое слово «yield» — такие функции возвращают объект-генератор. 
В Python генераторы - это инструмент для создания итераторов. Представляют собой функцию, содержащую в своем теле ключевое слово «yield» в том месте, где необходимо вернуть данные. Генератор хранит значения переменных и состояние выполнения, и при вызове метода __next__() возобновляет работу с места остановки. Отличие генератора от итератора:
a) генератор реализован в виде функции
b) генератор автоматически реализует методы __iter__() и __next__()
c) генератор автоматически сохраняет между вызовами значения локальных переменных и состояние выполнения
d) генератор автоматически вызывает StopIteration при завершении
-------Пример-------
def generator(n):
    i = 0
    while i < n:
        yield a
	i += 1

for el in my_gen(10):
    print(el)
--------------------


11) Контекст менеджер
	Менеджеры контекста служат для автоматизации освобождения ресурсов. В python менеджер контекста реализан как объект с методами __enter__() и __exit___(). __enter__() вызывается при входе в блок with и возвращает ссылку на объект, которая присваивается переменной после ключевого слова as. __exit___() выполняется при выходе из контекста.

-------Пример-------
class File:
    def __init__(self, file_path, method):
        self.path = file_path
        self.method = method

    def __enter__(self):
        self.file = open(self.path, self.method)
        return self.file

    def __exit__(self, exc_type, exc_value, exc_traceback):
        self.file.close()

my_file = File("hello.txt", "w")
with my_file as f:
    f.write("hello") 
--------------------



12) Дескрипторы
	Дескриптор - объект, класс которого определяет любой из трёх методов протокола дескриптора:
__get__(self, obj, type=None) --> value
__set__(self, obj, value) --> None
__delete__(self, obj) --> None

Дескрипторы используются в качестве атрибутов класса. Такие атрибуты могут иметь изменённую логику при присвоении, получении значения и удалении атрибута. Например, можно проверять, удовлетворяет ли присваимое значение некоторому условию.

-------Пример-------
class Integer:
    def __set_name__(self, obj, name):
            self.name = name
    
    def __get__(self, obj, objtype):
        return obj.__dict__[self.name]
    
    def __set__(self, obj, value):
        assert isinstance(value, int), "Not integer"
        obj.__dict__[self.name] = value

class A:
    val = Integer()
    
    def __init__(self, value):
        self.val = value

a = A(10)
print(a.val)
a.val = "hello"
print(a.val)
--------------------